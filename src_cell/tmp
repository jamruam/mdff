#ifdef debug
  ! =======================================
  !   calculate forces from field and EFG
  ! =======================================
   do ia = 1, natm
     fxc(ia) = qia( ia ) * Efield(ia,1) + mu_tot( ia , 1 ) * efg_t( ia , 1 , 1 ) + &
                                          mu_tot( ia , 2 ) * efg_t( ia , 2 , 1 ) + &
                                          mu_tot( ia , 3 ) * efg_t( ia , 3 , 1 )
     fyc(ia) = qia( ia ) * Efield(ia,2) + mu_tot( ia , 1 ) * efg_t( ia , 1 , 2 ) + &
                                          mu_tot( ia , 2 ) * efg_t( ia , 2 , 2 ) + &
                                          mu_tot( ia , 3 ) * efg_t( ia , 3 , 2 )
     fzc(ia) = qia( ia ) * Efield(ia,3) + mu_tot( ia , 1 ) * efg_t( ia , 1 , 3 ) + &
                                          mu_tot( ia , 2 ) * efg_t( ia , 2 , 3 ) + &
                                          mu_tot( ia , 3 ) * efg_t( ia , 3 , 3 )
   enddo

    WRITE ( stdout , '(a)' ) 'forces at atoms from field and field gradient : '
    do ia = 1 , natm
      WRITE ( stdout , '(i5,a3,a,3f18.10)' ) &
      ia,atype(ia),' f  = ' , fxc ( ia )        , fyc ( ia )        , fzc ( ia )
    enddo
    WRITE ( stdout , '(a)') ' '
    do ia = 1 , natm
      WRITE ( stdout , '(i5,a3,a,3f18.10)' ) &
      ia,atype(ia),' E  = ' , Efield ( ia , 1 ) , Efield ( ia , 2 ) , Efield ( ia , 3 )
    enddo
    WRITE ( stdout , '(a)') ' '
    do ia = 1 , natm
      WRITE ( stdout , '(i5,a3,a,3f18.10)' ) &
      ia,atype(ia),' mu = ', mu_tot ( ia , 1 ) , mu_tot ( ia , 2 ) , mu_tot ( ia , 3 )
    enddo
    WRITE ( stdout , '(a)') ' '
#endif


   if ( longrange .eq. 'direct' ) CALL Nymand_Linse_output ( 'DS' , '  '  , u_coul_tot , phi_coul_tot , Efield , efg_t , fx , vir_coul_tot , natm )
   if ( longrange .eq. 'ewald' )  CALL Nymand_Linse_output ( 'ES' , ' 1'  , u_coul_tot , phi_coul_tot , Efield , efg_t , fx , vir_coul_tot , natm )




!*********************** SUBROUTINE Efield_and_scf_induced *********************
!
! this subroutine is an interface to the calculation of the electric field from 
! point charges and dipoles. it also calculate the induced moment in a SCF procedure.
! 
!  if lfield_only = .TRUE. : we calculate only energy , potential and electric fields
! 
!******************************************************************************

SUBROUTINE driver_coulombic_no_md ( iastart, iaend , mu_tot , Efield , lfield_only ) 

  USE io_file , ONLY : stdout , ionode
  USE config,   ONLY : natm , natmi , ntype , atype , rx , ry , rz , phi_coul_tot , phi_coul_qq , phi_coul_dd , fx , fy , fz , dipia
  USE control,  ONLY : longrange
  USE thermodynamic,   ONLY : u_coul_qq, u_coul_dd , u_coul_qd , vir_coul_dd , vir_coul_qq , vir_coul_qd , u_coul_tot , vir_coul_tot

  implicit none

  ! global
  integer, intent(in)           :: iastart , iaend 
  double precision, intent ( out ) :: mu_tot ( natm , 3 ) 
  double precision, intent ( out ) :: Efield ( natm , 3 )
  logical :: lfield_only

  ! local 
  integer :: ia , iscf , it 
  double precision :: efield_old , diff_efield , conv_tol
  double precision :: Efield_stat ( natm , 3 ) , Efield_ind ( natm , 3 ) , tmp( natm , 3 ) 
  double precision :: mu_ind ( natm , 3 ) 
  double precision :: phi_coul ( natm ) 
  double precision :: u_coul , vir_coul , u_pol
  logical :: linduced

  fx           = 0.0d0 
  fy           = 0.0d0 
  fz           = 0.0d0
  mu_ind       = 0.0d0
  u_coul_tot   = 0.0d0  
  u_coul_qq    = 0.0d0  
  u_coul_dd    = 0.0d0 
  u_coul_qd    = 0.0d0 
  u_pol        = 0.0d0
  vir_coul_tot = 0.0d0 
  vir_coul_qq  = 0.0d0 
  vir_coul_dd  = 0.0d0 
  vir_coul_qd  = 0.0d0
  phi_coul_qq  = 0.0d0
  phi_coul_dd  = 0.0d0
  phi_coul_tot = 0.0d0

  ! =============================================
  !  calculate static Efield ( charge + dipoles )
  ! =============================================
  Efield_stat = 0.0d0

  ! =============================================
  !  coulombic energy , forces (field) and virial 
  ! =============================================
  if ( longrange .eq. 'direct' ) CALL engforce_charge_DS ( iastart, iaend , tmp ) 
  if ( longrange .eq. 'ewald' )  CALL engforce_charge_ES ( iastart, iaend , tmp ) 
  Efield_stat = Efield_stat + tmp
  tmp = 0.0d0
  fx = 0.0d0 ; fy = 0.0d0 ; fz = 0.0d0
  ! =============================================
  !  Electric Field from (static) dipoles i.e lmu_input=.FALSE.
  ! =============================================
  if ( longrange .eq. 'direct' ) CALL engforce_dipole_DS ( iastart , iaend , tmp , mu_ind , lmu_input=.FALSE. ) 
  if ( longrange .eq. 'ewald' )  CALL engforce_dipole_ES    ( iastart , iaend , tmp , mu_ind , lmu_input=.FALSE. )
  Efield_stat = Efield_stat + tmp
  mu_ind = 0.0d0
  fx = 0.0d0 ; fy = 0.0d0 ; fz = 0.0d0
  tmp = 0.0d0

  ! =============================================
  !  init total Efield to static only 
  ! =============================================
  Efield = Efield_stat 

  ! =============================================
  !  Is there any polarizability ? if yes linduced = .TRUE.
  ! =============================================
  linduced = .false.
  do it = 1 , ntype
    if ( lpolar ( it ) .eq. 1 ) linduced = .true.
  enddo
  
  !====================================================================================================================================
  !                           BEGIN OF INDUCED MOMENT CALCULATION FROM POLARIZABILITIES
  !====================================================================================================================================

induced:  if ( linduced .and. .not. lfield_only ) then

    if ( ionode ) WRITE ( stdout , '(a)' ) 'calculate induced dipole SCF'

  
    if ( ionode ) then
      WRITE ( stdout , '(a)' ) 'We start from the static electric field (charge + static dipole)'
      WRITE ( stdout , '(a)' ) ' '
    endif
    diff_efield = 1000.0d0
    Efield_old  = Efield(1,1)
    iscf = 0
    ! =============================
    !           SCF LOOP
    ! =============================
    conv_tol = 1e-6 !hardware
    do while ( iscf .lt. 3 ) 
!    do while ( diff_efield .gt. conv_tol .or. iscf .lt. 2 ) 
      
      iscf = iscf + 1 

      ! ==========================================================
      !  calculate mu_ind from Efield = Efield_stat + Efield_ind
      ! ==========================================================
      CALL induced_moment ( Efield , mu_ind , u_pol )  ! Efield in ; mu_ind and u_pol out 

#ifdef debug
   do ia =1 , natm 
     write( stdout , '(a,3f12.5)' ) 'debug : induced moment from pola', mu_ind ( ia , 1 ),  mu_ind ( ia , 2 ) , mu_ind ( ia , 3 )
   enddo
   do ia =1 , natm 
     write( stdout , '(a,3f12.5)' ) 'debug : Efield                  ', Efield ( ia , 1 ),  Efield ( ia , 2 ) , Efield ( ia , 3 )
   enddo
#endif

      ! ==========================================================
      !  calculate Efield_ind from mu_ind 
      !  Efield_ind out , mu_ind in
      ! ==========================================================
      if ( longrange .eq. 'direct' ) CALL engforce_dipole_DS ( iastart , iaend , Efield_ind , mu_ind , lmu_input = .TRUE. )
      if ( longrange .eq. 'ewald' )  CALL engforce_dipole_ES ( iastart , iaend , Efield_ind , mu_ind , lmu_input = .TRUE. )
      fx = 0.0d0 ; fy = 0.0d0 ; fz = 0.0d0

      Efield = Efield_stat + Efield_ind

      ! ===================
      !  stopping criteria
      ! ===================
      diff_efield = dabs ( Efield(1,1) - Efield_old ) 
      Efield_old = Efield(1,1)
  
      if ( ionode ) WRITE ( stdout ,'(a,i4,a,3f18.10,2(a,f18.10))') &
      'scf = ',iscf,' Efield atom 1= ',Efield(1,1),Efield(1,2),Efield(1,3),' conv = ',diff_efield,' u_pol = ',u_pol

    enddo ! end of SCF loop

    if ( ionode ) then
      WRITE ( stdout , '(a)' ) ' '
      WRITE ( stdout , '(a,i6,a)') 'scf calculation of the induced electric moment converged in ',iscf, ' iterations '
      WRITE ( stdout , '(a,e10.3)') 'Electric field is converged within ',conv_tol
      WRITE ( stdout , '(a)' ) ' '
      WRITE ( stdout , '(a)' )     'Induced dipoles at atoms : '
      do ia = 1 , natm
        WRITE ( stdout , '(i5,a3,a,3f18.10)' ) &
        ia,atype(ia),' mu_ind = ', mu_ind ( ia , 1 ) , mu_ind ( ia , 2 ) , mu_ind ( ia , 3 )
      enddo
      WRITE ( stdout , '(a)' ) ' '
    endif

  endif induced 
  !====================================================================================================================================
  !                           END OF INDUCED MOMENT CALCULATION FROM POLARIZABILITIES
  !====================================================================================================================================

  ! ==========================
  !  total dipole
  ! ==========================
  mu_tot = dipia + mu_ind

#ifdef debug
  do ia = 1 , natm
    WRITE ( stdout ,'(a,i6,a,3f10.5)') 'debug : mu_tot',ia,'      = ',mu_tot(ia,1),mu_tot(ia,2),mu_tot(ia,3)
  enddo
  do ia = 1 , natm
    WRITE ( stdout ,'(a,i6,a,3f10.5)') 'debug : dipia',ia,'      = ',dipia(ia,1),dipia(ia,2),dipia(ia,3)
  enddo
  do ia = 1 , natm
    WRITE ( stdout ,'(a,i6,a,3f10.5)') 'debug : mu_ind',ia,'      = ',mu_ind(ia,1),mu_ind(ia,2),mu_ind(ia,3)
  enddo
  WRITE( stdout , '(a)') 'debug :  check if mu_tot = dipia + mu_ind' 
#endif

  ! =============================================
  !  calculate field , forces ... 
  ! =============================================
  Efield = 0.0d0 
  ! =============================================
  !  coulombic energy , forces (field) and virial 
  ! =============================================
  if ( longrange .eq. 'direct' ) CALL engforce_charge_DS ( iastart, iaend , tmp )
  if ( longrange .eq. 'ewald'  ) CALL engforce_charge_ES    ( iastart, iaend , tmp )
  Efield = Efield + tmp
  tmp = 0.0d0
  ! =============================================
  !  Electric Field from (static) dipoles i.e linduced=.FALSE.
  ! =============================================
  if ( longrange .eq. 'direct' ) CALL engforce_dipole_DS ( iastart , iaend , tmp , mu_tot , lmu_input=.TRUE. )
  if ( longrange .eq. 'ewald' )  CALL engforce_dipole_ES    ( iastart , iaend , tmp , mu_tot , lmu_input=.TRUE. )
  Efield = Efield + tmp
  tmp = 0.0d0

  if ( longrange .eq. 'direct' ) CALL engforce_charge_and_dipole_DS ( iastart , iaend , mu_tot , lmu_input=.TRUE. )
!  if ( longrange .eq. 'ewald' ) CALL engforce_charge_and_dipole_ES ( iastart , iaend , mu_tot , lmu_input=.TRUE. )

  u_coul_tot   = u_coul_qq   + u_coul_dd   + u_coul_qd + u_pol
  vir_coul_tot = vir_coul_qq + vir_coul_dd + vir_coul_qd
  phi_coul_tot = phi_coul_qq + phi_coul_dd

  if ( ionode ) then
    WRITE ( stdout , '(a)' ) ' '
    WRITE ( stdout , '(a)' )     'Electric field at atoms : '
    do ia = 1 , natm
      WRITE ( stdout , '(i5,a3,a,3f18.10)' ) &
      ia,atype(ia),' Efield3 = ', Efield ( ia , 1)  , Efield ( ia , 2 ) , Efield ( ia , 3 )
    enddo
    WRITE ( stdout , '(a)' ) ' '

    WRITE ( stdout , '(a)' ) ' '
    WRITE ( stdout , '(a)' ) 'forces at atoms : '
    do ia = 1 , natm
      WRITE ( stdout , '(i5,a3,a,3f18.10)' ) &
      ia,atype(ia),' f = ', fx ( ia )  , fy ( ia ) , fz ( ia )
    enddo
    WRITE ( stdout , '(a)' ) ' '
     WRITE ( stdout , '(a)' ) ' '
    WRITE ( stdout , '(a)' ) ' potential : '
    do ia = 1 , natm 
      WRITE ( stdout , '(i5,a3,3(a,f18.10))' ) &
      ia,atype(ia),' phi_tot = ', phi_coul_tot ( ia )  , ' phi_qq = ', phi_coul_qq (ia) , ' phi_dd = ', phi_coul_dd (ia) 
    enddo
    WRITE ( stdout , '(a)' ) ' '
    WRITE ( stdout , '(a)' ) 'Energy and virial : '
    WRITE ( stdout , '(5(a,f18.10))' ) &
    ' u_coul_tot   = ', u_coul_tot  ,' u_coul_qq   = ',u_coul_qq      ,' u_coul_qd   = ', u_coul_qd     ,' u_coul_dd   = ',u_coul_dd   ,' u_pol = ', u_pol
    WRITE ( stdout , '(4(a,f18.10))' ) &
    ' vir_coul_tot = ',vir_coul_tot ,' vir_coul_qq = ',vir_coul_qq    ,' vir_coul_qd = ', vir_coul_qd   ,' vir_coul_dd = ',vir_coul_dd
  endif


  return

END SUBROUTINE driver_coulombic_no_md



SUBROUTINE Nymand_and_Linse_systems 

  USE config,   ONLY :  system , natm , ntype , atype , rx , ry , rz , itype , &
                        atypei , natmi, rho , box , omega , config_alloc 
                       
  USE control,  ONLY :  longrange , myrank , numprocs 
  USE io_file,  ONLY :  ionode , stdout , kunit_OUTFF , kunit_TRAJFF
  USE efg


  implicit none

  ! local
  integer :: it 
  integer :: iastart , iaend


  OPEN (UNIT = kunit_TRAJFF , FILE = 'TRAJFF')

  READ ( kunit_TRAJFF, * )  natm
  READ ( kunit_TRAJFF, * )  system
  READ ( kunit_TRAJFF, * )  box,ntype
  READ ( kunit_TRAJFF ,* ) ( atypei ( it ) , it = 1 , ntype )
  IF ( ionode ) WRITE ( kunit_OUTFF ,'(A,20A3)' ) 'found type information on TRAJFF : ', atypei ( 1:ntype )
  IF ( ionode ) WRITE ( stdout      ,'(A,20A3)' ) 'found type information on TRAJFF : ', atypei ( 1:ntype )
  READ( kunit_TRAJFF ,*)   ( natmi ( it ) , it = 1 , ntype )
  omega = box * box * box
  rho = natm / omega
  ! ===================================
  !  here we know natm, then alloc 
  !  and decomposition can be applied 
  ! ================================== 
  CALL config_alloc
  CALL do_split ( natm , myrank , numprocs , iastart , iaend )
  ! read charge in fieldtag
  CALL field_init
  CALL efg_alloc
  ! =============
  !  print info
  ! =============
  CALL efg_print_info(stdout)
  CALL efg_print_info(kunit_OUTFF)

  CALL print_general_info( stdout )
  CALL print_general_info( kunit_OUTFF )


  return

END SUBROUTINE Nymand_and_Linse_systems

SUBROUTINE Nymand_Linse_output ( label , labelES , U , pot , Efield , EFG , fx , vir , natm )

  USE io_file,  ONLY : stdout

  implicit none

  ! global
  integer :: natm
  double precision :: U , vir
  double precision :: pot ( natm ) , fx ( natm )
  double precision :: Efield ( natm , 3 ) , EFG ( natm , 3 , 3 )
  character(len=2) label , labelES


  WRITE ( stdout , '(a)' ) ''
  WRITE ( stdout , '(a)' ) 'Nymand, Linse output'
  WRITE ( stdout , '(a)' ) ''
  WRITE ( stdout , 490 ) 'Method ',' surf ',' phi_1 ',' E1,x ', 'E1,xx ',' E1,yy ',' f1,x ',' PHI '
  WRITE ( stdout , 500 ) label , labelES, U , pot(1) , Efield ( 1 , 1 ) , EFG ( 1 , 1 , 1 ) , EFG ( 1 , 2 , 2 ) , fx ( 1 ) , vir
  WRITE ( stdout , '(a)' ) ''

490 FORMAT(A,A,7A12)
500 FORMAT(A,A,7F12.7)

  return

END SUBROUTINE Nymand_Linse_output








